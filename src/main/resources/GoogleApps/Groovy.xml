<?xml version="1.0" encoding="UTF-8"?>
<!--
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
-->

<xwikidoc>
  <web>GoogleApps</web>
  <name>Groovy</name>
  <language/>
  <defaultLanguage/>
  <translation>0</translation>
  <parent>GoogleApps.WebHome</parent>
  <creator>xwiki:XWiki.Admin</creator>
  <author>xwiki:XWiki.Admin</author>
  <customClass/>
  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>
  <creationDate>1420066800000</creationDate>
  <date>1420066800000</date>
  <contentUpdateDate>1420066800000</contentUpdateDate>
  <version>1.1</version>
  <title/>
  <defaultTemplate/>
  <validationScript/>
  <comment/>
  <minorEdit>false</minorEdit>
  <syntaxId>xwiki/2.0</syntaxId>
  <hidden>true</hidden>
  <content>import com.google.api.client.auth.oauth2.Credential;
import com.google.api.client.googleapis.auth.oauth2.*;
import com.google.api.ads.common.lib.auth.*;
import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport;
import com.google.api.client.http.HttpTransport;
import com.google.api.client.json.jackson2.JacksonFactory;
import com.google.api.client.json.JsonFactory;
import com.google.api.client.util.store.MemoryDataStoreFactory;

import com.google.api.services.drive.DriveScopes;
import com.google.api.services.drive.model.*;
import com.google.api.services.drive.Drive;

import com.google.gdata.client.docs.DocsService;
import com.google.gdata.data.*;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.List;

import org.apache.velocity.tools.generic.EscapeTool;
import org.apache.commons.lang.RandomStringUtils;

public class GoogleAppsGroovy {

// Config Page
def CONFIG_PAGE = "GoogleApps.GoogleAppsConfig";
def CONFIG_CLASS = "GoogleApps.GoogleAppsConfigClass";
def FEED_URL = "https://www.googleapis.com/drive/v2/files";

// is Application Active
def active = false;

def APPNAME; 
def CLIENTID; 
def SECRET; 
def SCOPE;
def DOMAIN;
def AUTH_PAGE = "GoogleApps.OAuth";
def REDIRECT_URI;

// xwiki variables
def xwiki;
def context;
def doc;
def request;
def response;

public static storedCredentials = new HashMap();
public static storedStates = new HashMap();

def escapetool = new EscapeTool();
def sdebug = new StringBuffer();

/** Global instance of the {@link FileDataStoreFactory}. */
def DATA_STORE_FACTORY = new MemoryDataStoreFactory();

def JSON_FACTORY = JacksonFactory.getDefaultInstance();

/** Global instance of the HTTP transport. */
def HTTP_TRANSPORT = GoogleNetHttpTransport.newTrustedTransport();

/** Global instance of the scopes required by this quickstart. */
def SCOPES = Arrays.asList(DriveScopes.DRIVE);

public getConfig(name) {
 def config = "";
 def configdoc = xwiki.getDocument(CONFIG_PAGE);
 configdoc.use(CONFIG_CLASS);
 def obj = configdoc.getDocument().getObject(CONFIG_CLASS);
 if (obj!=null) {
   config = (obj.get(name)!=null) ? obj.get(name).getValue() : "";
 }
 if (config=="") {
   configdoc = xwiki.getDocument("xwiki:" + CONFIG_PAGE);
   configdoc.use(CONFIG_CLASS);
   obj = configdoc.getDocument().getObject(CONFIG_CLASS);
   if (obj!=null) {
     config = (obj.get(name)!=null) ? obj.get(name).getValue() : "";
   }
 }
 return config;
}

public init(xwiki, context, doc) {
 this.xwiki = xwiki;
 this.context = context;
 this.doc = doc;

 this.request = context.request;
 this.response = context.response;
 
 
 this.APPNAME  = getConfig("appname");
 this.CLIENTID  = getConfig("clientid");
 this.SECRET  = getConfig("secret");
 this.SCOPE  = getConfig("scope");
 this.DOMAIN  = getConfig("domain");
 this.active  = getConfig("active");
 this.REDIRECT_URI = xwiki.getDocument(AUTH_PAGE).getExternalURL("view");
 
 addDebug("APPNAME: ${APPNAME}");
 addDebug("CLIENTID: ${CLIENTID}");
 addDebug("SCOPE: ${SCOPE}");
}

public addDebug(str) {
 sdebug.append(str);
 sdebug.append("\n");
 System.println("GOOGLEAPPS: ${str}");
}

public getDebug() {
 return sdebug.toString();
}

public isActive() {
 return active;
}

def getFlow() {
   // Build flow and trigger user authorization request.
   GoogleAuthorizationCodeFlow flow =
                new GoogleAuthorizationCodeFlow.Builder(
                        HTTP_TRANSPORT, JSON_FACTORY, CLIENTID, SECRET, SCOPES)
                .setDataStoreFactory(DATA_STORE_FACTORY)
                .setAccessType("offline")
                .build();
   return flow;
}

  /**
   * Exchange an authorization code for OAuth 2.0 credentials.
   *
   * @param authorizationCode Authorization code to exchange for OAuth 2.0
   *     credentials.
   * @return OAuth 2.0 credentials.
   */
  def exchangeCode(String authorizationCode) {
    try {
      def flow = getFlow();
      def tokenResponse = flow
          .newTokenRequest(authorizationCode)
          .setRedirectUri(REDIRECT_URI)
          .execute();
      addDebug("Token: " + tokenResponse)
      return flow.createAndStoreCredential(tokenResponse, context.user);
    } catch (e) {
      addDebug("An error occurred: " + e);
      e.printStackTrace();
      return null;
    }
  }

 def storeCredentials(userId, credentials) {
   addDebug("Storing credentials for user " + userId);
   return storedCredentials.put(userId, credentials); 
 }
 def getStoredCredentials(userId) {
   addDebug("Getting credentials for user " + userId);
   return storedCredentials.get(userId); 
 }

/**
   * Retrieve credentials using the provided authorization code.
   *
   * This function exchanges the authorization code for an access token and
   * queries the UserInfo API to retrieve the user's e-mail address. If a
   * refresh token has been retrieved along with an access token, it is stored
   * in the application database using the user's e-mail address as key. If no
   * refresh token has been retrieved, the function checks in the application
   * database for one and returns it if found or throws a NoRefreshTokenException
   * with the authorization URL to redirect the user to.
   *
   * @param authorizationCode Authorization code to use to retrieve an access
   *     token.
   * @param state State to set to the authorization URL in case of error.
   * @return OAuth 2.0 credentials instance containing an access and refresh
   *     token.
   * @throws IOException Unable to load client_secret.json.
   */
  def getCredentials(String authorizationCode) throws IOException {
      return getCredentials(authorizationCode, true);
  }

  def getCredentials(String authorizationCode, redirect)
      throws IOException {
      Credential credentials = null;
     
      if (authorizationCode!=null &amp;&amp; authorizationCode!="") {
       addDebug("Trying to get credentials from authorization code: ${authorizationCode}");
       credentials = (authorizationCode==null) ? null : exchangeCode(authorizationCode);
       if (credentials!=null) {
        def rtoken = credentials.getRefreshToken();
        if (rtoken != null) {
         addDebug("Refresh token has been created: " + rtoken);
         storeCredentials(context.user, credentials);
         return credentials;
        } else {
         addDebug("Failure to create refresh token");
         storeCredentials(context.user, credentials);
         return credentials;
        }
       }
      }
 
      if (credentials==null) {
        addDebug("No credentials found. Checking stored credentials for user " + context.user);
        credentials = getStoredCredentials(context.user);
        if (credentials != null) {
            addDebug("Retrieved stored credentials");
            return credentials;
        }
        addDebug("Could not find stored credentials");
      }

      addDebug("No credentials retrieved.");
      // No refresh token has been retrieved.
      if (redirect) {
       addDebug("Redirecting to authorization URL.");
       response.sendRedirect(getAuthorizationURL());
      }
 }


 def getAuthorizationURL() {
   def state = "";
   if (doc.fullName!="GoogleApps.OAuth") {
     def finalRedirect = request.getRequestURL().toString();
     def qs = request.getQueryString();
     if (qs!=null &amp; qs!="")
      finalRedirect += "?" + qs;
     state = finalRedirect.hashCode().toString();
     storedStates.put(state, finalRedirect);
   }

   def urlBuilder = getFlow()
        .newAuthorizationUrl()
        .setRedirectUri(REDIRECT_URI)
        .setState(state);
    return urlBuilder.build();
 }

 def authorize() throws IOException {
   return authorize(true);
 }

 def authorize(redirect) throws IOException {
        addDebug("In authorize")
        def flow = getFlow();
        def creds = getCredentials(request.code, redirect);
        addDebug("Got credentials: ${creds}")
        if (request.state &amp;&amp; request.state!="") {
           def url = storedStates.get(request.state);
           if (url!=null) {
            addDebug("Redirecting to final destination after authorieation: ${url}")
            response.sendRedirect(url)
           }
        }
        return creds;
 }

  /**
     * Build and return an authorized Drive client service.
     * @return an authorized Drive client service
     * @throws IOException
     */
  def getDriveService() throws IOException {
        Credential credential = authorize();
        return new Drive.Builder(
                HTTP_TRANSPORT, JSON_FACTORY, credential)
                .setApplicationName(APPNAME)
                .build();
    }

   /**
     * Build and return an authorized Drive client service.
     * @return an authorized Drive client service
     * @throws IOException
     */
  def getDocsService() throws IOException {
        Credential credential = authorize();
        def service = new DocsService(APPNAME);
        service.setOAuth2Credentials(credential);
        return service;
 }


 public getDocumentList() {
   def drive = getDriveService();
   def result = drive.files().list().setMaxResults(10).execute();
   return result;
 }

 public importFromGoogleApps(query, nbResults) {
   def drive = getDriveService(); 
   def req = drive.files().list().setQ(query).setFields("items(id,mimeType,title,exportLinks,selfLink,version,alternateLink)").setMaxResults(nbResults);
   def result = req.execute();   
   return result;
 }

public listDocuments(query, nbResults) {
   def drive = getDriveService(); 
    // .setFields("items(id,mimeType,title,selfLink,version,alternateLink,embedLink)")
   def req = drive.files().list().setQ(query).setMaxResults(nbResults);
   def result = req.execute();   
   return result;
 }


public retrieveFileFromGoogle(page, id, name) {
   def adoc = xwiki.getDocument(page);
   def docsService = getDocsService();
   try {
      def data = downloadFile(docsService, id);
      saveFileToXWiki(docsService, adoc, name, data, true);
   } catch (Exception e) {
     addDebug(e.getMessage())
     e.printStackTrace();
   }
 }


def byte[] downloadFile(docsService, String exportUrl) {
  def mc = new MediaContent();
  mc.setUri(exportUrl);
  def ms = docsService.getMedia(mc);

  InputStream inStream = null;
  ByteArrayOutputStream outStream = new ByteArrayOutputStream();

  try {
    inStream = ms.getInputStream();

    int c;
    while ((c = inStream.read()) != -1) {
      outStream.write(c);
    }
  } finally {
    if (inStream != null) {
      inStream.close();
    }
    if (outStream != null) {
      outStream.flush();
      outStream.close();
    }
  }
  return outStream.toByteArray();
}

public saveFileToXWiki(client, adoc, name, data, redirect) {
  def attachment = adoc.addAttachment(name, data);

  // ready to save now
  adoc.getDoc().saveAttachmentContent(attachment.getAttachment(), context.getContext());
  adoc.save("Updated Attachment From Google Apps");   
  
  def object = adoc.getObject("GoogleApps.SynchronizedDocumentClass", "fileName", name.toString(), false);
  if (object==null) {
   object = adoc.newObject("GoogleApps.SynchronizedDocumentClass")
  }
  adoc.use(object);
  adoc.set("id", request.id)
  adoc.set("fileName", name)
  adoc.set("exportLink", request.url)
  if (request.version)
   adoc.set("version", request.version)
  if (request.editLink)
   adoc.set("editLink", request.editLink)
  adoc.save("Updated Google Apps Document metadata")
  addDebug("Document ${name} has been saved to XWiki")

 if (redirect) {
   def rurl = adoc.getURL("view", "#Attachments")
   context.response.sendRedirect(rurl);
 }
}

 public getGoogleDocument(pageName, fileName) {
   def adoc = xwiki.getDocument(pageName);
   def object = adoc.getObject("GoogleApps.SynchronizedDocumentClass", "fileName", fileName, false);
   if (object==null) {
    return null;
   } else {
    adoc.use(object);
    return [ "id" : adoc.getValue("id"), "editLink" : adoc.getValue("editLink"), "exportLink" : adoc.getValue("exportLink")]
   }
 }

 public getExportLink(docName, elink) {
  def index = elink.indexOf("exportFormat=") + 13;
  def extension = elink.substring(index);
  addDebug("Found extension: " + extension);
  def newDocName = docName.replaceAll("\\.(doc|docx|odt|xls|xlsx|ods|pptx|pdf|svg|png|jpeg|pdf|)\$","")
  newDocName += "." + extension;
  addDebug("Found extension: " + extension);
  addDebug("Found new DocName: " + newDocName);
  return [ "type" : extension, "newDocName" : newDocName];
 }

 public getFileDisplayInfo(mimeType, docName) {
  def newDocName;
  def availableTypes;
    if (mimeType.endsWith("document")) {
      newDocName = docName.replaceAll("\\.doc\$","").replaceAll("\\.docx\$","").replaceAll("\\.odt\$","");
      availableTypes = [ "odt", "doc", "pdf" ];
    } else if (mimeType.endsWith("spreadsheet")) {
      newDocName = docName.replaceAll("\\.xls\$","").replaceAll("\\.xlsx\$","").replaceAll("\\.ods\$","");
      availableTypes = [ "ods", "xls", "xlsx", "pdf" ];
    } else if (mimeType.endsWith("presentation")) {
      newDocName = docName.replaceAll("\\.ppt\$","").replaceAll("\\.pptx\$","").replaceAll("\\.odp\$","");
      availableTypes = [ "pptx", "pdf", "svg", "png", "jpeg" ];
    } else if (mimeType.endsWith("pdf")) {
      newDocName = docName.replaceAll("\\.pdf\$","").replaceAll("\\.pdf\$","").replaceAll("\\.pdf\$","");
      availableTypes = [ "pdf" ];
    } else if (mimeType.endsWith("drawing")) {
      newDocName = docName.replaceAll("\\.svg\$","");
      availableTypes = [ "svg", "png", "jpeg", "pdf" ];
    } else if (mimeType.endsWith("folder")) {
      newDocName = docName;
      availableTypes = [ "folder" ];
    } else {
      newDocName = docName;
      availableTypes = [ "" ];
    }
   return [ docName : newDocName, availableTypes : availableTypes ]
 }

/*
public getExistingFile(client, name) {
  DocumentQuery dquery = new DocumentQuery(new URL(FEED_URL));
  dquery.setTitleQuery(name);
  dquery.setTitleExact(true);
  dquery.setMaxResults(1);
  def resultFeed = client.getFeed(dquery, DocumentListFeed.class);
  def entries = resultFeed.getEntries();
  if (entries.size()&gt;0)
    return entries.get(0);
  else
    return null;
}

public saveAttachmentInGoogle(adoc, name, entry) {
  def data = adoc.getAttachment(name).getContentAsBytes();
  entry.setMediaSource(new MediaByteArraySource(data, xwiki.getXWiki().getEngineContext().getMimeType(name)));
  return entry.updateMedia(true);
}

public createAttachmentInGoogle(client, adoc, name) {
  def tmaindir = xwiki.getXWiki().getTempDirectory(context.getContext());
  def tdir = new File(tmaindir, RandomStringUtils.randomAlphanumeric(8));
  try { 
       // save temporary file to disk
       tdir.mkdirs();
       def file = new File(tdir, name);
       if (!file.exists())
            file.createNewFile();
       def fos = new FileOutputStream(file);
       fos.write(adoc.getAttachment(name).getContentAsBytes())
       fos.close();

       String mimeType = DocumentListEntry.MediaType.fromFileName(name).getMimeType();
       DocumentListEntry newDocument = new DocumentListEntry();
       newDocument.setFile(file, mimeType);
       newDocument.setTitle(new PlainTextConstruct(name));

       def result = client.insert(new URL(FEED_URL), newDocument);
       return result;
  } finally {
       if (tmaindir!=null)
         tmaindir.delete();
  }
}
 
public getExportURL(entry, name) {
 def ext = name.substring(name.indexOf(".")+1);
 return entry.getContent().getUri() + "&amp;exportFormat=" + ext;
}

public checkFileExists(page, name) {
 def adoc = xwiki.getDocument(page);
 if (isAuthenticated()) {
  try {
   def client = getDocsClient();
   return getExistingFile(client, name)
  } catch (Exception e) {
   addDebug("Authentication Fail")
   addDebug(e.getMessage())
   e.printStackTrace();
   sendAuthRequest();
  }
 }  else {
   sendAuthRequest();
 } 
}

public saveAttachmentToGoogle(page, name, overwrite) {
 def adoc = xwiki.getDocument(page);
  if (isAuthenticated()) {
  try {
    def client = getDocsClient();
    if (overwrite) {
      def entry = getExistingFile(client, name);
      return saveAttachmentInGoogle(adoc, name, entry);
    } else {
      return createAttachmentInGoogle(client, adoc, name);
    }
  } catch (Exception e) {
   addDebug("Authentication Fail")
   addDebug(e.getMessage())
   e.printStackTrace();
   sendAuthRequest();
  }
 }  else {
   sendAuthRequest();
 } 
}


 */

}</content>
</xwikidoc>
